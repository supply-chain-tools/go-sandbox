# `gitverify` Threat Model

The primary feature of `gitverify` is to verify that all the commits in a Git repository is signed with known identities.

It can also add rules to restrict what `maintainers`, `contributors` and the `forge` can do.

In general `gitverify` adds restrictions to `git` in order to mitigate potential attacks and/or make analysis about
possible attacks easier.

### At Most Two Commit Parents
To make the analysis easier, and because it's not common to have more, `gitverify` will fail with an
error if any commit has more than two parents.

### Contributors
Contributors are not allowed to sign tags or merge commits into protected branches. By not allowing forges to create
merge commits (`forgeRules.allowMergeCommits: false`), only maintainer keys are allowed to sign merges into protected branches.

### Forge
The forge can be allowed to merge PRs (`forgeRules.allowMergeCommits: true`), but not make content changes
(`forgeRules.allowContentCommits: false`). While this reduces the attack surface compared to arbitrary commits 
it should not be used if the forge is untrusted without other mitigations. Mitigations could include reviewing the
merges before cutting a release in a way the forge cannot tamper with.

The author of forge commits is verified to match a `maintainer` or `contributor` so that the same rules can be applied
as if it was signed with the `maintainer`'s or `contributor`'s key.

Metadata manipulation attacks are separate from the `forgeRules.allowMergeCommits` and `forgeRules.allowContentCommits`
settings.

### Tags
Teleportation attacks on signed annotated tags are detected. Lightweight tags cannot
be protected from such attacks.

Teleportation attacks where the `refs/tags/<tag>` differ from the annotated tag object are also detected even if
`rules.requireSignedTags: false` is set (when unsigned the attacker can manipulate both to match).

### Protected Branches
Merge commits into protected branches are verified to be made by maintainers directly or by the forge on their behalf if
`forge.AllowMergeCommit: true`. If `rules.requireUpToDate: true`, then the branch being merged into the protected
branch needs to be up-to-date with the protected branch before the merge. This is useful to make sure that the feature
branch is reviewed and tested in combination with the protected branch before it is merged.

Rules that apply to a protected branch are run for all matching local (`refs/heads/<protected branch>`) and
upstream (`refs/remotes/<remotes>/<protected branch>`) branches.

### SHA-512
`repository.after.sha1`/`repository.after.sha512` and `exemptTag.hash.sha1`/`exemptTag.hash.sha512` can be used with either SHA-1,
SHA-512, or both. This can mitigate SHA-1 collision attacks for those hashes, and recursively for the state that is needed
to compute those hashes.

Furthermore, the local state also keep track of tags and protected branches using SHA-512.

### `after`
Either `after.sha1` or `after.sha512` must be set for all repositories. Ancestor commits of `after` will be ignored, as well as `after` itself.
Each `after` must be present in the repository. This reduces the chance of accidentally using the config for the wrong repo. The commit timestamp should
make it likely to be unique even if `after` points to an initial, autogenerated commit.

If breaking changes to the config is made, or invalid changes are made to the repository, updating `after` is a way to get
back to a working state. It is up to the user to make sure that they are updating `after` to a safe value.

Protected branches must have a matching `after.branch` as an ancestor following the first parent recursively.
I.e. `after` must be a commit on the protected branch rather than one merged into the protected branch. This is to reduce the set of valid commits
for the protected branch. Without this any commit made with the same key that otherwise fulfill the protected branch
requirements would be valid, including commits from another repository. Any of the `after` is allowed which could
still allow teleportation within or across repositories.

When combined with `--commit <SHA-1>` on the command line, the commit is verified to exist in the repository and be a
descendant of any `after`. If `after.branch` is set then it will verify against that specific hash.

The number of `after` should be minimized and be unique for the repository.

When both `after.sha1` and `after.sha512` are set then they are verified to point to the same commit.

### Content Changes in Merge Commits
It can be useful to detect if a merge commit not only merged two branches, but introduced other changes like
resolving a conflict or adding unrelated changes.

In `gitverify` merge commits into a protected branch cannot contain content changes. The rationale is that feature branches
will be used and that any conflicts should be resolved in the feature branch before merging.

Forges can be allowed to merge PRs but not make content changes by setting `forgeRules.allowMergeCommits: true` and
`forgeRules.allowContentCommits: false`.

The test for content changes in merge commits is the same for protected branches and forges. A [`git merge-tree`](https://git-scm.com/docs/git-merge-tree)
is performed and the resulting merged tree is compared to the tree in the commit. I.e. not allowing a content
change means that the file tree in the resulting commit must match merging the two parents with the [default merge strategy](https://git-scm.com/docs/git-merge#_merge_strategies).
Hopefully, using the default strategy is common, otherwise we might have to support setting the merge strategy in the future.

`--allow-unrelated-histories` is not set, so the two branches must share history.

**Please note: the current approach should be changed:**
- `git merge-tree` creates the merged object tree in the repository. In the common case, this will be identical
  to the existing tree that is being verified, but if they differ it will have crated new state.
- `git merge-tree` recently got support for `--strategy-option`, but does not have support to set the strategy.
  `--strategy-option` is left unset to be compatible with more versions of `git`. Since neither of these are set, if the
  default behaviour of `git merge-tree` changes in the future, this will be a problem for the check. Similarly, if `git merge`
  and `git merge-tree` diverge, it will be a problem.


### Metadata Manipulation Attacks
Protected branches and tags can be tracked by clients through local state. This way deletion and rollback attacks are
limited to when the local state was last updated.

Branch teleportation attacks depend on other settings: when using `protectedBranches` a teleportation
can only occur to a commit that is a descendant of the stored tip of the protected branch. Furthermore, it must be a
descendant through the first parent recursively, not simply be reachable. By setting `requireMergeCommits` those parents
can only be merge commits. Similarly, `protectedBranches` must have a matching `after.branch` so even if the local state
is missing, there must be a connection to the `after` commit.

All this structure makes it less likely that a suitable teleportation target exist. When a feature branch is created
it might not contain merge commits, and then it cannot be used for teleportation. Typical merge commits on feature branches
will either not involve the protected branch, or it will merge the changes from the protected branch into the feature branch,
making the feature branch the second parent, not the first, and thus it cannot be a teleportation target. In other words,
the protected branch is typically only the first parent in a merge commit when something is being merged into the protected
branch. If a maintainer creates a fork and merge something into the protected branch of the fork, that will be a valid
teleportation target.

The analysis is similar for other branches, like release branches. We could also add detection if a suitable teleportation target exists,
but an attacker controlling the state might hide it.

If `forgeRules.allowMergeCommits` is set, then the forge can create merge commits rather than relying on a merge target
to exist. One malicious merge commit can be hard to detect, especially if the same commit will be performed by the
maintainers through the forge at a later stage.

None of `gitverify`'s features help mitigate split views, where different clients see different valid versions of the
repository. And unless `after` or the local state is constantly synced between clients, there is room to manipulate the
metadata. Full protection against metadata manipulation attacks does not seem possible without something like the
Reference State Log (RSL) described in [Preventing Git Metadata Tampering That
(Re)introduces Software Vulnerabilities](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/torres-arias).
